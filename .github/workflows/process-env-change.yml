name: Process structured environment JSON change
on:
  issues:
    types: [opened, edited]
permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  apply:
    if: contains(github.event.issue.labels.*.name, 'account_amendment')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract issue form data
        id: form
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || "";
            const fields = {};
            const normalize = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]+/g, ' ').replace(/\s+/g, ' ').trim();
            const toKey = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');
            // Map human labels from Issue Form to canonical keys
            const labelMap = new Map([
              ["App name (matches JSON filename in environments/)", "account_name"],
              ["Target environment", "environment_name"],
              ["Change action", "environment_change_action"],
              ["Current SSO group name (for amend)", "current_sso_group_name"],
              ["Current access level (for amend)", "current_level"],
              ["SSO group name", "sso_group_name"],
              ["Access level", "level"],
              ["Change action (additional reviewers)", "reviewers_change_action"],
              ["Current additional reviewers (for amend)", "current_additional_reviewers"],
              ["Additional reviewers (comma-separated)", "additional_reviewers"],
              ["Change action (tags)", "tags_change_action"],
              ["Current tag key (for amend)", "current_tag_key"],
              ["Current tag value (for amend)", "current_tag_value"],
              ["Tag key", "tag_key"],
              ["Tag value", "tag_value"],
              ["Change action (other)", "other_change_action"],
              ["Current GitHub OIDC team repositories (for amend)", "current_github_oidc_team_repositories"],
              ["Current go-live date (for amend)", "current_go_live_date"],
              ["GitHub OIDC team repositories (comma-separated)", "github_oidc_team_repositories"],
              ["Go-live date (DD-MM-YYYY)", "go_live_date"],
            ]);

            // Map common heading IDs to canonical keys (supports awk-style ### id + value)
            const idMap = new Map([
              ["app_name", "account_name"], ["account_name", "account_name"],
              ["environment_name", "environment_name"], ["environment", "environment_name"], ["env", "environment_name"],
              ["environment_change_action", "environment_change_action"], ["change_action", "environment_change_action"],
              ["current_sso_group_name", "current_sso_group_name"], ["current_group", "current_sso_group_name"],
              ["current_level", "current_level"],
              ["sso_group_name", "sso_group_name"], ["group", "sso_group_name"],
              ["level", "level"],
              ["reviewers_change_action", "reviewers_change_action"],
              ["current_additional_reviewers", "current_additional_reviewers"],
              ["additional_reviewers", "additional_reviewers"],
              ["tags_change_action", "tags_change_action"],
              ["current_tag_key", "current_tag_key"], ["current_tag_value", "current_tag_value"],
              ["tag_key", "tag_key"], ["tag_value", "tag_value"],
              ["other_change_action", "other_change_action"],
              ["current_github_oidc_team_repositories", "current_github_oidc_team_repositories"],
              ["current_go_live_date", "current_go_live_date"],
              ["github_oidc_team_repositories", "github_oidc_team_repositories"],
              ["go_live_date", "go_live_date"],
            ]);

            const lines = body.split(/\r?\n/);
            // Pass 1: Heading-style parser (### id then next non-empty line is value)
            for (let i = 0; i < lines.length; i++) {
              const labelLine = lines[i].trim();
              if (!labelLine) continue;
              const headingMatch = labelLine.match(/^#{2,}\s*(.+?)\s*$/);
              if (headingMatch) {
                const headingText = headingMatch[1];
                let idKey = idMap.get(toKey(headingText));
                // Fallback: treat heading text as a known label via labelMap
                if (!idKey && labelMap.has(headingText)) {
                  idKey = labelMap.get(headingText);
                }
                if (idKey) {
                  // find next non-empty, non-heading line
                  let j = i + 1, value = "";
                  while (j < lines.length) {
                    const v = lines[j].trim();
                    j++;
                    if (v === "" || /^#{2,}\s*/.test(v)) continue;
                    value = v;
                    break;
                  }
                  fields[idKey] = value;
                  fields[toKey(headingText)] = value;
                }
                continue; // move to next line
              }
              // Skip markdown non-field headings
              if (labelLine.startsWith("###") || labelLine.startsWith("####")) continue;
              const norm = normalize(labelLine);
              let matchedKey = null;
              // Try exact label match first
              if (labelMap.has(labelLine)) matchedKey = labelMap.get(labelLine);
              // Fuzzy match: normalize and compare/contains
              if (!matchedKey) {
                for (const [lbl, key] of labelMap.entries()) {
                  const normLbl = normalize(lbl);
                  if (norm === normLbl || norm.includes(normLbl)) { matchedKey = key; break; }
                }
              }
              // If label matches any known label, read next non-empty line as value
              if (matchedKey) {
                let j = i + 1, value = "";
                while (j < lines.length) {
                  const v = lines[j].trim();
                  j++;
                  if (v === "" || v.startsWith("###") || v.startsWith("####")) continue;
                  value = v;
                  break;
                }
                if (matchedKey) fields[matchedKey] = value;
                const rawKey = toKey(labelLine);
                fields[rawKey] = value;
              }
              // Also support inline 'Label: value' format
              const m = labelLine.match(/^([^:]+):\s*(.*)$/);
              if (m) {
                const humanLabel = m[1].trim();
                const value = m[2].trim();
                let key = labelMap.get(humanLabel);
                if (!key) {
                  const normLbl = normalize(humanLabel);
                  for (const [lbl, k] of labelMap.entries()) {
                    if (normLbl === normalize(lbl) || normLbl.includes(normalize(lbl))) { key = k; break; }
                  }
                }
                if (key) fields[key] = value;
                const rawKey = toKey(humanLabel);
                fields[rawKey] = value;
              }
            }
            const get = k => fields[k] || "";
            let account = get('account_name');
            if (!account) {
              const title = context.payload.issue.title || "";
              const m = title.match(/amend\s+([a-z0-9_-]+)/i);
              if (m) account = m[1];
            }
            // Fallback: try to infer account from repo environments directory
            if (!account) {
              const { owner, repo } = context.repo;
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path: 'environments' });
                const entries = Array.isArray(res.data) ? res.data : [];
                const names = entries.filter(e => e.type === 'file' && e.name.endsWith('.json')).map(e => e.name.replace(/\.json$/, ''));
                const nameSet = new Set(names.map(n => n.toLowerCase()));
                // scan title and body for tokens that match file names
                const scanText = `${title}\n${body}`.toLowerCase();
                for (const name of names) {
                  if (scanText.includes(name.toLowerCase())) { account = name; break; }
                }
              } catch (err) {
                // ignore API errors; leave account empty
              }
            }
              // If still empty, try values from parsed fields
              if (!account) {
              try {
                const { owner, repo } = context.repo;
                const res = await github.rest.repos.getContent({ owner, repo, path: 'environments' });
                const entries = Array.isArray(res.data) ? res.data : [];
                const names = entries.filter(e => e.type === 'file' && e.name.endsWith('.json')).map(e => e.name.replace(/\.json$/, ''));
                const nameSet = new Set(names.map(n => n.toLowerCase()));
                for (const [k,v] of Object.entries(fields)) {
                  const val = (v || '').toLowerCase().replace(/[^a-z0-9_-]/g, '');
                  if (nameSet.has(val)) { account = v; break; }
                }
              } catch (err) {
                // ignore API errors
              }
              }
              // Final fallback: prefer common raw keys
              if (!account) {
                account = get('app_name') || get('account-name') || get('account_name') || fields['app_name_matches_json_filename_in_environments'] || fields['app_name_matches_json_filename_in_environments_'];
              }
            core.setOutput('account_name', account);
            const preview = body.slice(0, 400).replace(/\n/g, '\\n');
            core.info(`Issue body preview (first 400 chars): ${preview}`);
            core.info(`Parsed fields: ${JSON.stringify(fields, null, 2)}`);
            core.info(`Resolved account_name: ${account}`);
            // Environment section
            core.setOutput('environment_change_action', get('environment_change_action'));
            core.setOutput('environment_name', get('environment_name'));
            core.setOutput('current_sso_group_name', get('current_sso_group_name'));
            core.setOutput('current_level', get('current_level'));
            core.setOutput('sso_group_name', get('sso_group_name'));
            core.setOutput('level', get('level'));

            // Reviewers section
            core.setOutput('reviewers_change_action', get('reviewers_change_action'));
            core.setOutput('current_additional_reviewers', get('current_additional_reviewers'));
            core.setOutput('additional_reviewers', get('additional_reviewers'));

            // Tags section
            core.setOutput('tags_change_action', get('tags_change_action'));
            core.setOutput('current_tag_key', get('current_tag_key'));
            core.setOutput('current_tag_value', get('current_tag_value'));
            core.setOutput('tag_key', get('tag_key'));
            core.setOutput('tag_value', get('tag_value'));

            // Other section
            core.setOutput('other_change_action', get('other_change_action'));
            core.setOutput('current_github_oidc_team_repositories', get('current_github_oidc_team_repositories'));
            core.setOutput('current_go_live_date', get('current_go_live_date'));
            core.setOutput('github_oidc_team_repositories', get('github_oidc_team_repositories'));
            core.setOutput('go_live_date', get('go_live_date'));

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Verify target JSON exists
        shell: bash
        run: |
          safe_account="$(echo "${{ steps.form.outputs.account_name }}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]//g')"
          target="environments/${safe_account}.json"
          echo "Resolved safe_account=${safe_account}"
          echo "Checking for ${target}"
          if [ ! -f "$target" ]; then
            echo "ERROR: Target JSON not found: $target" >&2
            echo "Available files in environments/:" >&2
            ls -1 environments | sed 's/^/  /' >&2 || true
            exit 1
          fi

      - name: Apply structured changes
        shell: bash
        run: |
          set -euo pipefail
          # Normalize section actions and values, providing safe defaults when action is 'skip'
          reviewers_action="${{ steps.form.outputs.reviewers_change_action }}"
          tags_action="${{ steps.form.outputs.tags_change_action }}"
          other_action="${{ steps.form.outputs.other_change_action }}"

          current_addl_reviewers="${{ steps.form.outputs.current_additional_reviewers }}"
          addl_reviewers="${{ steps.form.outputs.additional_reviewers }}"
          current_tag_key="${{ steps.form.outputs.current_tag_key }}"
          current_tag_value="${{ steps.form.outputs.current_tag_value }}"
          tag_key="${{ steps.form.outputs.tag_key }}"
          tag_value="${{ steps.form.outputs.tag_value }}"
          current_oidc_repos="${{ steps.form.outputs.current_github_oidc_team_repositories }}"
          current_go_live="${{ steps.form.outputs.current_go_live_date }}"
          oidc_repos="${{ steps.form.outputs.github_oidc_team_repositories }}"
          go_live="${{ steps.form.outputs.go_live_date }}"

          if [[ "$reviewers_action" == "skip" ]]; then
            current_addl_reviewers=""
            addl_reviewers=""
          fi
          if [[ "$tags_action" == "skip" ]]; then
            current_tag_key=""
            current_tag_value=""
            tag_key=""
            tag_value=""
          fi
          if [[ "$other_action" == "skip" ]]; then
            current_oidc_repos=""
            current_go_live=""
            oidc_repos=""
            go_live=""
          fi

          args=(
            --account-name "${{ steps.form.outputs.account_name }}"
            --environment-change-action "${{ steps.form.outputs.environment_change_action }}"
            --environment-name "${{ steps.form.outputs.environment_name }}"
            --current-sso-group-name "${{ steps.form.outputs.current_sso_group_name }}"
            --current-level "${{ steps.form.outputs.current_level }}"
            --sso-group-name "${{ steps.form.outputs.sso_group_name }}"
            --level "${{ steps.form.outputs.level }}"
            # Reviewers
            --reviewers-change-action "$reviewers_action"
            --current-additional-reviewers "$current_addl_reviewers"
            --additional-reviewers "$addl_reviewers"
            # Tags
            --tags-change-action "$tags_action"
            --current-tag-key "$current_tag_key"
            --current-tag-value "$current_tag_value"
            --tag-key "$tag_key"
            --tag-value "$tag_value"
            # Other
            --other-change-action "$other_action"
            --current-github-oidc-team-repositories "$current_oidc_repos"
            --current-go-live-date "$current_go_live"
            --github-oidc-team-repositories "$oidc_repos"
            --go-live-date "$go_live"
          )

          python3 scripts/process_env_changes.py "${args[@]}"

      - name: Open PR
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Structured env JSON change (issue #${{ github.event.issue.number }})"
          body: |
            Automated structured change from issue #${{ github.event.issue.number }}.
            File: environments/${{ steps.form.outputs.account_name }}.json
            Environment action: ${{ steps.form.outputs.environment_change_action }} (env='${{ steps.form.outputs.environment_name }}')
            Reviewers action: ${{ steps.form.outputs.reviewers_change_action }}
            Tags action: ${{ steps.form.outputs.tags_change_action }}
            Other action: ${{ steps.form.outputs.other_change_action }}
          branch: "env-json/${{ github.event.issue.number }}"
          commit-message: "Structured env JSON change from issue #${{ github.event.issue.number }}"
          add-paths: |
            environments/${{ steps.form.outputs.account_name }}.json
          labels: account_amendment
